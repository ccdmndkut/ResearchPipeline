Hereâ€™s a matching project scaffold and file-placement plan for the flow you diagrammed.
The goal is to mirror each major box in your ASCII chart with a clear Python module or function so the whole pipeline is easy to extend or swap.

â¸»

ðŸ—‚ Suggested Folder / File Layout

research-pipeline/
â”œâ”€ README.md
â”œâ”€ requirements.txt
â”œâ”€ .env.example
â”‚
â”œâ”€ app/
â”‚  â”œâ”€ __init__.py
â”‚  â”œâ”€ main.py                # create_app(), register_routes(), run_dev()
â”‚  â”œâ”€ routes.py              # query(), index(), health()
â”‚  â”œâ”€ pipeline/
â”‚  â”‚   â”œâ”€ __init__.py
â”‚  â”‚   â”œâ”€ orchestrator.py    # run_pipeline(), plan_workflow(), call_llm(), merge_results()
â”‚  â”‚   â”œâ”€ loaders.py         # load_documents(), validate_schema()
â”‚  â”‚   â”œâ”€ graph_builder.py   # build_graph()
â”‚  â”‚   â”œâ”€ cleaners.py        # clean_text(), detect_language(), chunk_text()
â”‚  â”‚   â”œâ”€ vector_store.py    # index_to_vectorDB(), retrieve_docs()
â”‚  â”‚   â”œâ”€ retrieval.py       # web_search(), summarize(), cite_sources()
â”‚  â”‚   â”œâ”€ utils.py           # read_config(), cache_result(), slugify()
â”‚  â”‚   â””â”€ composer.py        # compose_response()
â”‚  â”œâ”€ templates/
â”‚  â”‚   â””â”€ index.html         # optional UI
â”‚  â””â”€ static/                # optional assets
â”‚
â””â”€ tests/
   â”œâ”€ test_routes.py
   â”œâ”€ test_pipeline.py
   â”œâ”€ test_graph_builder.py
   â””â”€ ...


â¸»

ðŸ”‘ Function Mapping (aligns with your diagram)

Diagram Box	Suggested File	Function(s)
create_app / register_routes / run_dev	app/main.py	create_app(), register_routes(app), run_dev()
query / index / health	app/routes.py	query(), index(), health()
run_pipeline / plan_workflow / call_llm / merge_results	app/pipeline/orchestrator.py	orchestrator logic, async coordination
load_documents / validate_schema	app/pipeline/loaders.py	I/O + schema checks
build_graph	app/pipeline/graph_builder.py	entity/relation extraction, KG creation
clean_text / detect_language / chunk_text	app/pipeline/cleaners.py	text normalization
index_to_vectorDB / retrieve_docs	app/pipeline/vector_store.py	embedding + semantic search
web_search / summarize / cite_sources	app/pipeline/retrieval.py	external retrieval + summarization
read_config / cache_result / slugify	app/pipeline/utils.py	configuration, caching helpers
compose_response	app/pipeline/composer.py	final LLM synthesis with citations/graph


â¸»

ðŸ’¡ Implementation Tips
	â€¢	Asynchronous Orchestrator
run_pipeline() should kick off load_documents(), build_graph(), and index_to_vectorDB() in parallel with asyncio.gather where possible.
	â€¢	Vector Store & Graph
	â€¢	vector_store.py can wrap FAISS/Pinecone.
	â€¢	graph_builder.py could use NetworkX or Neo4j driver.
	â€¢	LLM Calls
	â€¢	Place all OpenAI API calls in call_llm() inside orchestrator.py or composer.py to keep secrets isolated.
	â€¢	Mock-Friendly
	â€¢	Each moduleâ€™s functions should accept injected clients (e.g., mock vector DB) to simplify testing.

â¸»

This scaffold matches your ASCII flow line-for-line, so anyone reading the code can jump from the diagram to the right file/function without guesswork.